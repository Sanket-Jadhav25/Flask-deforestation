# -*- coding: utf-8 -*-
"""Download_Server.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/123Dg4XEFbp2CtC4rDcMsvfO5Bnuj4Lvi

##imports
"""

# pip install area
# pip install rasterio

import ee
import numpy as np
from rasterio import plot
from area import area as Area
import pandas as pd
import time
import ast 
import ee
from tqdm import tqdm
import os

import ee
service_account = 'app-615@oceanic-sky-309907.iam.gserviceaccount.com'
credentials = ee.ServiceAccountCredentials(service_account, 'oceanic-sky-309907-46e1e5d18543.json')
ee.Initialize(credentials)

def credentials_from_file(filename):
    """Load credentials from a service account file
    Args:
        None
    Returns: service account credential object
    
    https://developers.google.com/identity/protocols/OAuth2ServiceAccount
    """
    
    from google.oauth2 import service_account
    import googleapiclient.discovery

    # https://developers.google.com/identity/protocols/googlescopes#drivev3
    SCOPES = [
        'https://www.googleapis.com/auth/drive'
    ]
    SERVICE_ACCOUNT_FILE = filename

    credentials = service_account.Credentials.from_service_account_file(
            SERVICE_ACCOUNT_FILE, scopes=SCOPES)
            
    return credentials

from apiclient import discovery

credentials2 = credentials_from_file('/content/oceanic-sky-309907-46e1e5d18543.json')
service = discovery.build('drive', 'v3', credentials=credentials2)

"""##functions

"""

def getGEEDataset(name,startDate,endDate,area,bands):
  # select collection with date range and filter bounds
  imgCollection=ee.ImageCollection(name).filterDate(startDate,endDate)
  # for band in bands:
  #   imgCollection=imgCollection.filter(ee.Filter.neq(band, None))
  # create image of the collection
  img = ee.Image(imgCollection.median())
  # select the needed bands
  # img_full = img.select(ee.List(bands))
  return img

def drive_transfer(img,name,cord,band_list,destination_folder):
# Specify patch and file dimensions.
  image_export_options = {
    'patchDimensions': [256, 256],
    'maxFileSize': 104857600,
    'compressed': True
  }

  # Setup the task.
  image_task = ee.batch.Export.image.toDrive(
    image=img,
    description= name,
    fileNamePrefix= name,
    scale=30,
    fileFormat='GeoTiff',
    region=cord,
    folder= destination_folder,
    formatOptions={
            "cloudOptimized": True
    },
  )
  image_task.start()
  # Block until the task completes.
  print('Running image export to Drive Storage...')
  while image_task.active():
    time.sleep(5)

  # Error condition
  if image_task.status()['state'] != 'COMPLETED':
    print('Error with image export.')
  else:
    print('Image export completed.')
  return None

"""Shrink Coordinate"""

from math import radians, cos, sin, asin, sqrt, degrees

def distance(edge): 
      
    # The math module contains a function named 
    # radians which converts from degrees to radians.
    if(edge[0] < edge[1]):
        lon1 = radians(edge[0][0]) 
        lat1 = radians(edge[0][1]) 
        lon2 = radians(edge[1][0]) 
        lat2 = radians(edge[1][1]) 
    else:
        lon1 = radians(edge[1][0]) 
        lat1 = radians(edge[1][1]) 
        lon2 = radians(edge[0][0]) 
        lat2 = radians(edge[0][1])

    # Haversine formula  
    dlon = lon2 - lon1  
    dlat = lat2 - lat1 
    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
  
    c = 2 * asin(sqrt(a))
       
    # calculate the result 
    return(c * 6371) 


def shrink_horizontal_coordinates(horizontal_edge, horizontal_distance):
    # The math module contains a function named 
    # radians which converts from degrees to radians. 
    lon1 = radians(horizontal_edge[0][0]) 
    lat1 = radians(horizontal_edge[0][1]) 
    lon2 = radians(horizontal_edge[1][0]) 
    lat2 = radians(horizontal_edge[1][1]) 
    dis = horizontal_distance
    #long2-long1 should be positive

    a = []

    if(lon2 > lon1):

        dis3 = dis/4 * 3
        a.append(degrees(-(  2*asin(sqrt((sin(dis3/(6371*2))**2)  *  1/(cos(lat1) * cos(lat2))))  ) + lon2))

    else:
        lon1 = lon2           #this will change the cordinates

        dis3 = (dis/4) * 3
        a.append(degrees(2*asin(sqrt((sin(dis3/(6371*2))**2)  *  1/(cos(lat1) * cos(lat2)))) + lon1))

    return(a) 



#incomplete
def shrink_vertical_coordinates(vertical_edge, vertical_distance):
    
    lon1 = radians(vertical_edge[0][0]) 
    lat1 = radians(vertical_edge[0][1]) 
    lon2 = radians(vertical_edge[1][0]) 
    lat2 = radians(vertical_edge[1][1]) 
    dis = vertical_distance
    a = []
      
    # calculate the result 
    if(lat1 < lat2): #lar1 is known


        dis3 = dis/4 * 3
        a.append(degrees(dis3/6371 + lat1))

    else:
        print("reached2")
        lat2 = lat1

        dis3 = dis/4 * 3
        a.append(degrees(-dis3/6371 + lat2))


    return(a) 

def shrink_total(cordinates): 

    horizontal_edge = list()
    vertical_edge    = list()

    horizontal_edge.append(cordinates[0][0])
    horizontal_edge.append(cordinates[0][1])
    vertical_edge.append(cordinates[0][1])
    vertical_edge.append(cordinates[0][2])


    unique_cordinates = {
        "horizontal_edge_coordinates" : [cordinates[0][1][0]],
        "vertical_edge_coordinates"   : [cordinates[0][1][1]]
    }


    horizontal_distance = distance(horizontal_edge)
    vertical_distance = distance(vertical_edge)

    # print(vertical_edge)

    unique_cordinates["horizontal_edge_coordinates"] = unique_cordinates["horizontal_edge_coordinates"] + shrink_horizontal_coordinates(horizontal_edge, horizontal_distance)
    unique_cordinates["vertical_edge_coordinates"] = unique_cordinates["vertical_edge_coordinates"] + shrink_vertical_coordinates(vertical_edge, vertical_distance)


    # horizontal_edge_coordinates = longitude = l
    # vertical_edge_coordinates = latitude    = b


    l = list(unique_cordinates["horizontal_edge_coordinates"])
    b = list(unique_cordinates["vertical_edge_coordinates"])


    rec1 = [    [
                [l[1],b[0]] , 
                [l[0],b[0]] , 
                [l[0],b[1]] , 
                [l[1],b[1]] , 
                [l[1],b[0]]]    
            ]


    return(rec1)

"""divide Grid"""

from math import radians, cos, sin, asin, sqrt, degrees
def distance(edge): 
      
    # The math module contains a function named 
    # radians which converts from degrees to radians.
    if(edge[0] < edge[1]):
        lon1 = radians(edge[0][0]) 
        lat1 = radians(edge[0][1]) 
        lon2 = radians(edge[1][0]) 
        lat2 = radians(edge[1][1]) 
    else:
        lon1 = radians(edge[1][0]) 
        lat1 = radians(edge[1][1]) 
        lon2 = radians(edge[0][0]) 
        lat2 = radians(edge[0][1])

    # Haversine formula  
    dlon = lon2 - lon1  
    dlat = lat2 - lat1 
    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
  
    c = 2 * asin(sqrt(a))
       
    # calculate the result 
    return(c * 6371) 


def horizontal_coordinates(horizontal_edge, horizontal_distance):
    # The math module contains a function named 
    # radians which converts from degrees to radians. 
    lon1 = radians(horizontal_edge[0][0]) 
    lat1 = radians(horizontal_edge[0][1]) 
    lon2 = radians(horizontal_edge[1][0]) 
    lat2 = radians(horizontal_edge[1][1]) 
    dis = horizontal_distance
    #long2-long1 should be positive

    a = []

    if(lon2 > lon1):
        dis1 = (dis/4)
        a.append(degrees(-(  2*asin(sqrt((sin(dis1/(6371*2))**2)  *  1/(cos(lat1) * cos(lat2))))  ) + lon2))
        dis2 = (dis/2)
        a.append(degrees(-(  2*asin(sqrt((sin(dis2/(6371*2))**2)  *  1/(cos(lat1) * cos(lat2))))  ) + lon2))
        dis3 = dis/4 * 3
        a.append(degrees(-(  2*asin(sqrt((sin(dis3/(6371*2))**2)  *  1/(cos(lat1) * cos(lat2))))  ) + lon2))

        a.append(horizontal_edge[0][0])
        # a=lon1
    else:
        lon1 = lon2           #this will change the cordinates
        dis1 = (dis/4)
        a.append(degrees(2*asin(sqrt((sin(dis1/(6371*2))**2)  *  1/(cos(lat1) * cos(lat2)))) + lon1))
        dis2 = (dis/2)
        a.append(degrees(2*asin(sqrt((sin(dis2/(6371*2))**2)  *  1/(cos(lat1) * cos(lat2)))) + lon1))
        dis3 = (dis/4) * 3
        a.append(degrees(2*asin(sqrt((sin(dis3/(6371*2))**2)  *  1/(cos(lat1) * cos(lat2)))) + lon1))

        a.append(horizontal_edge[0][0])
        # a=lon2
    # lon2 = 2*a + lon1       
    # calculate the result 
    return(a) 



#incomplete
def vertical_coordinates(vertical_edge, vertical_distance):
    
    lon1 = radians(vertical_edge[0][0]) 
    lat1 = radians(vertical_edge[0][1]) 
    lon2 = radians(vertical_edge[1][0]) 
    lat2 = radians(vertical_edge[1][1]) 
    dis = vertical_distance
    a = []
      
    # calculate the result 
    if(lat1 < lat2): #lar1 is known
        dis1 = (dis/4)
        a.append(degrees(dis1/6371 + lat1))
        
        dis2 = (dis/2)
        a.append(degrees(dis2/6371 + lat1))

        dis3 = dis/4 * 3
        a.append(degrees(dis3/6371 + lat1))

        a.append(vertical_edge[1][1])
        # a = lat2
    else:
        print("reached2")
        lat2 = lat1

        dis1 = (dis/4)
        a.append(degrees(-dis1/6371 + lat2))

        dis2 = (dis/2)
        a.append(degrees(-dis2/6371 + lat2))

        dis3 = dis/4 * 3
        a.append(degrees(-dis3/6371 + lat2))

        a.append(vertical_edge[1][1])
        # a = lat1

    return(a) 

def grid(cordinates): 

    horizontal_edge = list()
    vertical_edge    = list()

    horizontal_edge.append(cordinates[0][0])
    horizontal_edge.append(cordinates[0][1])
    vertical_edge.append(cordinates[0][1])
    vertical_edge.append(cordinates[0][2])


    unique_cordinates = {
        "horizontal_edge_coordinates" : [cordinates[0][1][0]],
        "vertical_edge_coordinates"   : [cordinates[0][1][1]]
    }


    horizontal_distance = distance(horizontal_edge)
    vertical_distance = distance(vertical_edge)

    # print(vertical_edge)

    unique_cordinates["horizontal_edge_coordinates"] = unique_cordinates["horizontal_edge_coordinates"] + horizontal_coordinates(horizontal_edge, horizontal_distance)
    unique_cordinates["vertical_edge_coordinates"] = unique_cordinates["vertical_edge_coordinates"] + vertical_coordinates(vertical_edge, vertical_distance)


    # horizontal_edge_coordinates = longitude = l
    # vertical_edge_coordinates = latitude    = b

    totalrect = []
    for x in range(0,4):
        
        l = list(unique_cordinates["horizontal_edge_coordinates"])
        b = list(unique_cordinates["vertical_edge_coordinates"])

        rec1 = [    [[l[x],b[0]] , [l[x + 1],b[0]] , [l[x + 1],b[1]] , [l[x],b[1]] , [l[x],b[0]]]    ]
        rec2 = [    [[l[x],b[1]] , [l[x + 1],b[1]] , [l[x + 1],b[2]] , [l[x],b[2]] , [l[x],b[1]]]    ]
        rec3 = [    [[l[x],b[2]] , [l[x + 1],b[2]] , [l[x + 1],b[3]] , [l[x],b[3]] , [l[x],b[2]]]    ]
        rec4 = [    [[l[x],b[3]] , [l[x + 1],b[3]] , [l[x + 1],b[4]] , [l[x],b[4]] , [l[x],b[3]]]    ]

        totalrect = totalrect + rec1 + rec2 + rec3 + rec4

    return(totalrect)

def check_missing(files):
  a=[0]*11
  for r in result:
    if '2007' in r['name']:
      a[0]=a[0]+1
    elif '2008' in r['name']:
      a[1]=a[1]+1
    elif '2009' in r['name']:
      a[2]=a[2]+1
    elif '2010' in r['name']:
      a[3]=a[3]+1
    elif '2011' in r['name']:
      a[4]=a[4]+1
    elif '2012' in r['name']:
      a[5]=a[5]+1
    elif '2013' in r['name']:
      a[6]=a[6]+1
    elif '2014' in r['name']:
      a[7]=a[7]+1
    elif '2015' in r['name']:
      a[8]=a[8]+1
    elif '2016' in r['name']:
      a[9]=a[9]+1
    else:
      a[10]=a[10]+1
    return a

def find_missing_years(files):
  missing_array=check_missing(files)
  if missing_array[10]!=0:
    raise Exception('Gadbad')
  else:
    error=[]
    for i,v in enumerate(missing_array[:10]):
      if v!=32:
        error.append(2007+i)
    return error

def find_missing_grid(year_data):
  a=[0]*16
  for r in year_data:
    if 'G0.' in r['name'] or 'G0_' in r['name']:
      a[0]=a[0]+1
    elif 'G1.' in r['name'] or 'G1_' in r['name']:
      a[1]=a[1]+1
    elif 'G2.' in r['name'] or 'G2_' in r['name']:
      a[2]=a[2]+1
    elif 'G3.' in r['name'] or 'G3_' in r['name']:
      a[3]=a[3]+1
    elif 'G4.' in r['name'] or 'G4_' in r['name']:
      a[4]=a[4]+1
    elif 'G5.' in r['name'] or 'G5_' in r['name']:
      a[5]=a[5]+1
    elif 'G6.' in r['name'] or 'G6_' in r['name']:
      a[6]=a[6]+1
    elif 'G7.' in r['name'] or 'G7_' in r['name']:
      a[7]=a[7]+1
    elif 'G8.' in r['name'] or 'G8_' in r['name']:
      a[8]=a[8]+1
    elif 'G9.' in r['name'] or 'G9_' in r['name']:
      a[9]=a[9]+1
    elif 'G10.' in r['name'] or 'G10_' in r['name']:
      a[10]=a[10]+1
    elif 'G11' in r['name'] or 'G11_' in r['name']:
      a[11]=a[11]+1
    elif 'G12.' in r['name'] or 'G12_' in r['name']:
      a[12]=a[12]+1
    elif 'G13.' in r['name'] or 'G13_' in r['name']:
      a[13]=a[13]+1
    elif 'G14.' in r['name'] or 'G14_' in r['name']:
      a[14]=a[14]+1
    elif 'G15.' in r['name'] or 'G15_' in r['name']:
      a[15]=a[15]+1
  a
  errors=[]
  for i,v in enumerate(a):
    if v!=2:
      errors.append(i)
  return a

def download_missing_data(year,grid,location):
  landsat=f"{location['Region']}_{location['Area']}_{year}_G{error_grid}.tif"
  idhao=f"{location['Region']}_{location['Area']}_{year}_G{error_grid}__Idaho.tif"
  if not find_file(landsat):
    download_specific(location,year,grid,landsat=True)
  elif not find_file(idhao):
    download_specific(location,year,grid,landsat=False)

def download_specific(location,year,grid,landsat=True):
  destination_folder="LandsatImages"
  # get location coordinates
  area=location['Co-ordinate']
  # genrate 4*4 grid of the coordinates
  elements=grid(area)
  # create earth engine geometry if the area
  area=ee.Geometry.Polygon(area, None, False)
  # create dict for new row in main df
  print('Years Done:')
  year_loop=tqdm([year])
  for year in year_loop:
    print(f'Year Selected {year}:')
    startDate =ee.Date.fromYMD(year,1,1)
    endDate =ee.Date.fromYMD(year,12,31)
    if landsat:
      if year <=2013:
        landsatDS="LANDSAT/LE07/C01/T1"
        landsatBands=["B2","B3","B4","B5","B7","B6_VCID_1"]
      else:
        landsatDS="LANDSAT/LC08/C01/T1"
        landsatBands=["B3","B4","B5","B6","B7","B10"]
      ee_image_landsat=getGEEDataset(name=landsatDS,startDate=startDate,endDate=endDate,area=area,bands=landsatBands)
      print(f"{location['Region']}_{location['Area']}_{year}_G{grid}")
      name=f"{location['Region']}_{location['Area']}_{year}_G{grid}"
      drive_transfer(img=ee_image_landsat,name=name,cord=elements[grid],band_list=landsatBands,destination_folder=destination_folder)
    else:
      IdahoDS="IDAHO_EPSCOR/TERRACLIMATE"
      IdahoBands=["tmmx","pdsi","vpd","ro","def"]
      ee_image_Idaho=getGEEDataset(name=IdahoDS,startDate=startDate,endDate=endDate,area=area,bands=IdahoBands)
      print(f"{location['Region']}_{location['Area']}_{year}_G{grid}_Idaho")
      name=f"{location['Region']}_{location['Area']}_{year}_G{grid}__Idaho"
      drive_transfer(img=ee_image_Idaho,name=name,cord=elements[grid],band_list=IdahoBands,destination_folder=destination_folder)

    print(f'Year {year} Done!')

"""##drive functions"""

def get_files(folderId,driveId=None):
  if driveId:
    corpora='drive'
    supportsAllDrives=True
    includeItemsFromAllDrives=True
  else:
    corpora=''
    supportsAllDrives=False
    includeItemsFromAllDrives=False
  page_token = None
  result=[]
  while True:
      response = service.files().list(q = f"'{folderId}' in parents",fields='nextPageToken, files(id, name)',
                                      supportsAllDrives=supportsAllDrives,
                                      driveId=driveId,
                                      corpora=corpora,
                                      includeItemsFromAllDrives =includeItemsFromAllDrives,pageToken=page_token).execute()
      for file in response.get('files', []):
          result.append(file)
      page_token = response.get('nextPageToken', None)
      if page_token is None:
          break
  return result

def get_all_folder_ids(driveId):
  page_token = None
  result=[]
  while True:
      response = service.files().list(q="mimeType='application/vnd.google-apps.folder'",
                                      driveId=driveId,
                                      corpora='drive',
                                      includeItemsFromAllDrives =True,
                                      fields='nextPageToken, files(id, name)',
                                      supportsAllDrives=True, 
                                      pageToken=page_token).execute()
      for file in response.get('files', []):
          # Process change
          # print ('Found file: %s (%s)' % (file.get('name'), file.get('id')))
          result.append({'name':file.get('name'), 'id':file.get('id')})
      page_token = response.get('nextPageToken', None)
      if page_token is None:
          break
  return result

#move file
# file_id = '***'
# folder_id = '***'
def move_file(file_id,folder_id):
  # Retrieve the existing parents to remove
  file = service.files().get(fileId=file_id, fields='parents').execute()
  previous_parents = ",".join(file.get('parents'))

  # Move the file to the new folder
  file = service.files().update(
      fileId=file_id,
      supportsAllDrives=True,
      addParents=folder_id,
      removeParents=previous_parents,
      fields='id, parents'
  ).execute()

def create_folder(name,parentID):
  file_metadata = {
    'name': name,
    'parents' : [parentID],
    'mimeType': 'application/vnd.google-apps.folder'
    }
  file = service.files().create(body=file_metadata,supportsAllDrives=True,fields='id').execute()
  return file.get('id')

def deletefile(fileId):
  service.files().delete(fileId=fileId,supportsAllDrives=True, ).execute()

def create_folder_and_move(folder_name):
  folder_name=f"{folder_name}"
  new_folder_id=create_folder(folder_name,driveFolderID)
  for file in files:
    move_file(file['id'],new_folder_id)
  return new_folder_id

def find_file(name):
  return drive_service.files().list(q=f"name='{name}'",fields='nextPageToken, files(id, name)',pageToken=page_token).execute()

"""##change this"""

location={'Area': 'Sant_Julia_de_Loria',
  'Co-ordinate': [[[1.2289239793090503, 42.36919824433563],
    [1.572418212890625, 42.36919824433563],
    [1.572418212890625, 42.541619138577296],
    [1.2289239793090503, 42.541619138577296],
    [1.2289239793090503, 42.36919824433563]]],
  'Region': 'Andorra',
  'User':'Username'}
years=[(x+2007) for x in range(0,10)]
years

def download(location,years):
  destination_folder="LandsatImages"
  # get location coordinates
  area=location['Co-ordinate']
  # genrate 4*4 grid of the coordinates
  elements=grid(area)
  # create earth engine geometry if the area
  area=ee.Geometry.Polygon(area, None, False)
  # create dict for new row in main df
  print('Years Done:')
  year_loop=tqdm(years)
  for year in year_loop:
    print(f'Year Selected {year}:')
    startDate =ee.Date.fromYMD(year,1,1)
    endDate =ee.Date.fromYMD(year,12,31)
    if year <=2013:
      landsatDS="LANDSAT/LE07/C01/T1"
      landsatBands=["B2","B3","B4","B5","B7","B6_VCID_1"]
    else:
      landsatDS="LANDSAT/LC08/C01/T1"
      landsatBands=["B3","B4","B5","B6","B7","B10"]
    IdahoDS="IDAHO_EPSCOR/TERRACLIMATE"
    IdahoBands=["tmmx","pdsi","vpd","ro","def"]
    ee_image_landsat=getGEEDataset(name=landsatDS,startDate=startDate,endDate=endDate,area=area,bands=landsatBands)
    ee_image_Idaho=getGEEDataset(name=IdahoDS,startDate=startDate,endDate=endDate,area=area,bands=IdahoBands)

    print('Grid Progress:')
    inner_loop=tqdm(range(0,len(elements)))
    inner_loop.reset()
    for i in inner_loop:
      print(f"{location['Region']}_{location['Area']}_{year}_G{i}_Idaho")
      name=f"{location['Region']}_{location['Area']}_{year}_G{i}__Idaho"
      drive_transfer(img=ee_image_Idaho,name=name,cord=elements[i],band_list=IdahoBands,destination_folder=destination_folder)
      print(f"{location['Region']}_{location['Area']}_{year}_G{i}")
      name=f"{location['Region']}_{location['Area']}_{year}_G{i}"
      drive_transfer(img=ee_image_landsat,name=name,cord=elements[i],band_list=landsatBands,destination_folder=destination_folder)
    print(f'Year {year} Done!')

"""##Drive"""

temp_drive_folderID='1ThixeSkEWstWCyT_zglH9hBp-5X2ySjE'
driveId='0AK91Kjn50C2rUk9PVA'
driveFolderID='1ops9kaA-UP5YmiW2Da3HFde9wNWJdCEo'

# download(location,years)

total_size=320

files=get_files(temp_drive_folderID)

while len(files)!=total_size: 
  missing_years=find_missing_years(files)
  for year in missing_years:
    year_data=[f for f in files if str(year) in r['name']]
    missing_grids=find_missing_grid(year_data)
    for grid in missing_grids:
      download_missing_data(year,grid,location)
  files=get_files(temp_drive_folderID)

new_folder_id=create_folder_and_move(location['User'])

get_files(driveFolderID,driveId=driveId)
# [{'id': '16kGWNe3fOKum_8IVNmaCZkGOJKto5e2L', 'name': 'Username'}]